1. static

   1. **全部静态变量**：静态存储区，整个程序运行期间一直存在，未经初始化会被自动初始化为0，全部静态变量在声明他的文件之外是不可见的，从定义之处开始，到文件结尾

   2. **局部静态变量**：静态存储区，作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变

   3. **静态函数**：在函数返回类型前加static，函数的定义和声明在默认情况下都是extern的，在声明的文件中可见，其他文件不能用，这个函数只能在本cpp内使用，不会和其他cpp的同名函数冲突，不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数

      如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰

   4. 类的静态成员：静态成员可以实现多个对象之间的数据共享，使用成员不会破坏隐藏的规则，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。

   5. 类的静态函数：在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>)

2. c++和c区别

​		设计思想：

​		c++ 面向对象，c面向过程

​		语法上：

​		封装、继承、多态三种特性

  1. 封装指的是将数据和操作数据的方法进行有机融合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互，封装本质上是一种管理

  2. 继承指的是可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展

  3. 多态指的是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数，实现多态的方式：重写、重载

     重写和重载的区别

     1. 重写是指派生类中存在定义的函数，其函数名、参数列表、返回值类型，所有都必须同基类中被重写的函数一致，只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数，重写的基类中被重写的函数必须有virtual修饰
     2. 重载用一个函数名定义多个函数，也就是所谓的函数重载，指同一可访问区内被声明的几个具有不同参数列的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型

​		增加类型安全的功能，强制类型转换

​		支持范式编程，模板类、函数模板

3. c++中static关键字的作用

   1. 对于函数定义和代码块之外的变量声明：修改标识符的链接属性，由默认的external变成internal，作用域和存储类型不改变，之恶写符号只能在声明他们的源文件中访问

   2. 对于代码块内部的变量声明：修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前创建，在程序执行的整个周期都存在

   3. 对于被static修饰的普通函数，只能在定义它的源文件使用，不能在其他源文件被引用

   4. 对于被static修饰的类成员变量和成员函数，是属于类而不是某个对象，所有对象共享一个静态成员，通过<类名>::<静态成员>使用

4. 四种cast转换

     向上转换：子类向基类的转换

     向下转换：基类向子类的转换

   1. const_cast:用于将const向量转为非const

   2. static_cast:用于各种隐式转换，比如非const转const，void*转指针，用于多态向上转化，如果向下转能成功但是不安全，结果未知

   3. dynamic_cast:用于动态类型转换，只能用于含有虚函数的类，用于类层次见的向上或向下转化，只能转指针或引用，向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常，要深入了解内部转换的原理。通过判断在执行到该语句的时候，变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换

   4. reinterpret_cast 几乎什么都可以转，比如将int转指针（尽量少用

   5. c的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查

5. c/c++中指针和引用的区别

   1. 引用

      C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了*

   2. 指针

      指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元

   3. 指针有自己的一块空间，引用只是一个别名

   4. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小

   5. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用

   6. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象

   7. 可以有const指针，但是没有const引用

   8. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变

   9. 指针可以有多级指针(**p)，而引用只有一级

   10. 指针和引用使用++运算符的意义不一样

   11. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏

6. smart pointer

   1. shared_ptr，unique_ptr，weak_ptr，auto_ptr(c++11已经弃用这个)

   2. 智能指针作用是管理指针，因为存在以下情况，申请的空间在函数结束时忘记释放，造成内存泄漏，而智能指针是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源，作用原理就是在函数结束时，自动释放内存空间

   3. auto_ptr采用所有权模式

      ```c++
      auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
      auto_ptr<string> p2;
      p2 = p1; //auto_ptr不会报错.
      ```

      此时不报错，p2剥夺了p1的所有权，但是当程序运行时访问p1会报错，所以auto_ptr缺点是存在潜在的内存崩溃问题

   4. unique_ptr采用所有权模式

      实现独占式拥有或严格拥有的概念，保证同一时间内只有一个智能指针可以指向该对象，对于避免资源泄漏（例如以new创建对象后因为发生异常而忘记调用delete）很有用

      ```c++
      unique_ptr<string> p3 (new string ("auto"));   //#4
      unique_ptr<string> p4；                       //#5
      p4 = p3;//此时会报错！！
      ```

      编译器认为p4=p3非法，避免了p3不再指向有效数据的问题，因此更安全。

      当程序试图将一个unique_ptr值赋给另一个时，如果源unique_ptr是个临时右值，编译器允许这么做，如果源unique_ptr将存在一段时间，编译器将禁止这么做

      ```c++
      unique_ptr<string> pu1(new string ("hello world"));
      unique_ptr<string> pu2;
      pu2 = pu1;                                      // #1 not allowed
      unique_ptr<string> pu3;
      pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
      ```

      其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr

      如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。

      ```c++
      unique_ptr<string> ps1, ps2;
      ps1 = demo("hello");
      ps2 = move(ps1);
      ps1 = demo("alexia");
      cout << *ps2 << *ps1 << endl;
      ```

   5. shared_ptr

      实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在”最后一个引用被销毁“时候释放，使用计数机制来表明资源被几个指针共享，可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr，unique_ptr，weak_ptr来构造，当我们调用release()时，当前指针会释放资源所有权，计数减一，当计数等于0时，资源会被释放

      shared_ptr是为了解决auto_ptr在对象所有权上的局限性(auto_ptr是独占的)，在使用引用计数的机制上提供了可以共享所有权的智能指针。

      成员函数包括：

       	1. use_count 返回引用计数的个数
       	2. unique 返回是否是独占所有权，use_count为1
       	3. swap交换两个shared_ptr对象
       	4. reset 放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少
       	5. get 返回内部对象（指针），由于已经重载了（）方法，因此和直接使用对象是一样的，如shared_ptr<int>sp(new int(1))，sp与sp.get()是等价的

   6. weak_ptr

      weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr

      ```c++
      class B;
      class A
      {
      public:
      shared_ptr<B> pb_;
      ~A()
      {
      cout<<"A delete\n";
      }
      };
      class B
      {
      public:
      shared_ptr<A> pa_;
      ~B()
      {
      cout<<"B delete\n";
      }
      };
      void fun()
      {
      shared_ptr<B> pb(new B());
      shared_ptr<A> pa(new A());
      pb->pa_ = pa;
      pa->pb_ = pb;
          
      cout<<pb.use_count()<<endl;
      cout<<pa.use_count()<<endl;
      }
      int main()
      {
      fun();
      return 0;
      }
      ```

      fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

      注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb\_->print(); 英文pb\_ 是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print()

7. 数组和指针的区别

   <img src="C:\Users\ZhouZixuan\AppData\Roaming\Typora\typora-user-images\image-20220301195932782.png" alt="image-20220301195932782" style="zoom:67%;" />

8. 野指针

   指向一个已删除的对象或者未申请访问受限内存区域的指针

9. 智能指针

   1. 管理在堆上分配的内存，将普通的指针封装为一个栈对象，当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。最常用的指针类型为shared_ptr，采用计数的方法，记录当前内存资源被多少智能指针引用，该引用计数的内存在堆上分配，当新增时引用计数加1，当过期时引用计数减1.只有引用计数为0时，智能指针才会自动释放引用的内存资源，对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类，可以通过make_shared函数或者通过构造函数传入普通指针，并通过get函数获得普通指针
   2. 内存泄漏：当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，是引用计数失效，从而导致内存泄漏。
   3. 如何解决内存泄漏：引入weak_ptr指针，其构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，类似一个普通指针，但不指向引用计数的内存共享，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问

10. 堆和栈

    1. 空间分配不同，栈由操作系统自动分配释放，存放函数的参数值，局部变量的值等，堆一般由程序员分配释放
    2. 缓存方式不同，栈使用的是一级缓存，通常都是被调用时处于存储空间中，调用完毕立即释放，堆则是存放在二级缓存中，速度要慢些
    3. 数据结构不同，堆类似数组结构，栈类似栈结构，先进后出

11. c++内存管理

    1. 内存分配方式

       1. 内存分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区
       2. 栈在执行函数时，函数内部局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储单元自动被释放
       3. 堆就是那些由new分配的内存块，一般一个new对应一个delete
       4. 自由存储区是那些由malloc分配的内存块，和堆十分相似，用free结束自己的生命
       5. 全局/静态存储区，全局变量和静态变量被分配到同一块内存中
       6. 常量存储区是一块特殊的存储区，里面存放的是常量，不允许修改

    2. 内存错误及解决对策

       1. 内存分配未成功，却使用了它
       2. 内存分配成功，但是尚未初始化就引用
       3. 内存分配成功并且已经初始化，但是操作越过了内存的边界
       4. 忘记了释放内存，造成内存泄漏
       5. 释放了内存却继续使用它

       对策：

       1. 定义指针时，先初始化为NULL
       2. 用malloc或new申请内存之后，应该立即检查指针值是否为NULL，防止使用指针值为NULL的内存
       3. 为数组和动态内存赋初值，防止将未被初始化的内存作为右值使用
       4. 避免数字或指针的下标越界
       5. 动态内存的申请和释放必须配对，防止内存泄漏
       6. 用free或者delete释放了内存之后，立即将指针设置为NULL，防止“野指针”
       7. 使用智能指针

    3. 内存泄漏几种情况：

       1. new和malloc申请资源使用后，没有用delete和free释放
       2. 子类继承父类时，父类析构函数不是虚函数
       3. windows句柄资源使用后没有释放

    4. malloc在堆上分配内存，需要程序员自己回收内存，局部变量是在栈中分配内存，超过作用域就自动回收

    5. <img src="C:\Users\ZhouZixuan\AppData\Roaming\Typora\typora-user-images\image-20220301212628754.png" alt="image-20220301212628754" style="zoom:67%;" />

    6. 程序启动过程：

       1. 操作系统创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中
       2. 加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库
       3. 加载器针对该程序的每一个动态链接库调用loadlibrary
       4. 初始化应用程序的全局变量，对于全局对象自动调用构造函数
       5. 进入应用程序入口点函数开始执行

    7. 初始化为0的全局变量存在BSS段，BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0

    8. atomoic内存顺序

       1. memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性
       2. memory_order_consume：只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作
       3. memory_order_acquire：使用该操作，当前线程的读写操作都不能重排到此操作之前
       4. memory_order_release：使用此操作，当前线程的读写操作都不能重排到此操作之后
       5. memory_order_acq_rel：在此内存顺序的读-改-写操作既是获得加载又是释放操作，没有操作能够从此
       6. memory_order_seq_cst：比acq更严格，不仅是一个获取释放内存顺序，还会对所有拥有此标签的内存操作建立一个单独全序
       7. 内存顺序选项对于所有原子类型默认都是memory_order_seq_cst

    9. 内存对齐的使用场景

       内存对齐应用于三种数据类型中struct/class/union，对其原则有四个

       1. 数据成员对齐规则：结构或联合的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
       2. 结构体作为成员，如果一个结构里有某些结构体成员，则结构体成员要从其内部最宽基本类型成员的整数倍地址开始存储
       3. 收尾工作：结构体的总大小，也就是sizeof()的结果，必须是其内部最大成员的最宽基本类型成员的整数倍，不足的要补齐，基本类型不包括struct/class/union
       4. sizeof(union)以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址

    10. 什么是内存对齐

        什么是字节对齐，在c语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型的变量，也可以是一些复合数据类型的数据单元，在结构体中，编译器为结构体的每个成员按其自然边界分配空间，每个成员按照他们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。

        为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的对齐，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称作自然对齐。

        字节对齐影响CPU访问数据的效率

    11. 什么是面向对象

        面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示

        面向过程：根据业务逻辑从上到下写代码

        面向对象：将数据和函数绑定到一起，进行封装，这样能够更快速地开发程序，减少了重复代码的重写过程

    12. 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数

        1. 用virtual关键字申明的函数叫虚函数，虚函数肯定是类的成员函数
        2. 存在虚函数的类都有一个一维的虚函数叫做虚表，类的对象有一个指向虚表开始的虚指针，虚表是和类对应的，虚表指针是和对象对应的
        3. 多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性
        4. 重写用虚函数来实现，结合动态绑定
        5. 纯虚函数是虚函数再加上=0
        6. 抽象类是指包括至少一个纯虚函数的类
        7. 纯虚函数：virtual void fun()=0 即抽象类必须在子类实现这个函数，即先有名称，没有内容，再派生类实现内容

    13. c语言如何实现重载

        1. 使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能
        2. 重载函数使用可变参数，方式如打开文件open函数
        3. gcc有内置函数，程序使用编译函数可以实现函数重载

    14. 构造函数

        分为默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数

        1. 默认构造函数和初始化构造函数在定义类的对象的时候，完成对象的初始化工作，有了有参的构造了，编译器就不提供默认的构造函数
        2. 拷贝构造函数赋值构造函数默认实现的是值拷贝（浅拷贝）
        3. 移动构造函数用于将其他类型的变量隐式转换为本类对象
        4. 只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数

    15. 定义一个空类会默认生成哪些函数

        1. 无参的构造函数、
        2. 拷贝构造函数，用于复制本类的对象
        3. 赋值运算符
        4. 析构函数（非虚）

    16. c++类对象的初始化顺序，有多重继承情况下的顺序

        1. 创建派生类的对象，基类的构造函数优先被调用，也优先于派生类里的成员类

        2. 如果类里面有成员类，成员类的构造函数优先被调用，也优先于该类本身的构造函数

        3. 基类构造函数如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序

        4. 成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序

        5. 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数，否则两个类的实现变成紧耦合的将更加难于正确地修改或扩展基类的实现，基类设计者的责任是提供一组适当的基类构造函数

        6. 初始化顺序为：父类构造函数–>成员类对象构造函数–>自身构造函数

           成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。

           析构顺序和构造顺序相反

    17. 向上转型和向下转型

        1. 子类转换为父类：向上转型，使用dynamic_cast<type_id>(expression)这种转换相对来说比较安全不会有数据的丢失
        2. 父类转为为子类：向下转型，可以使用强制转换，这种转换是不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存

    18. 浅拷贝

        又称值拷贝，将源对象的值拷贝到目标对象中，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的

    19. 深拷贝

        拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置，即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误
        
    20. 深拷贝的实现，深拷贝的拷贝构造函数和赋值运算符的重载传统实现
    
        拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象
    
    21. c++中的多态
    
        由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态
    
        1. 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错
    
        2. 动态多态：需要动态绑定条件
    
           虚函数，基类中必须有虚函数，在派生类中必须重写虚函数
    
           通过基类类型的指针或引用来调用虚函数
    
           重写：基类中有一个虚函数，在派生类中也要重写一个原型都相同的虚函数，不过协变例外，协变是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针
    
    22. 为什么要虚析构，不能虚构造
    
        1. 虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏，如果基类的析构函数不是虚函数，在特定情况下会导致派生类无法被析构
           1. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
           2. 用基类类型指针绑定派生类实例，析构的时候如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏，出现这种现象是因为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数，如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。
           3. C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数
        2. 不能虚构造
           1. 从存储空间角度：虚函数对应一个vtable，这个表的地址是存储在对象的内存空间的，如果将构造函数设置为虚函数，就需要到vtable中调用，可是对象还没有实例化，没有内存空间分配，如何调用（悖论）
           2. 从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用，构造函数本身就是要初始化实例，那使用虚函数就没有实际意义。所以构造函数没有必要是虚函数，虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的1，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数
           3. 从实现上看，vtable在构造函数调用后才建立，因为构造函数不可能成为虚函数，从实际含义上看，在调用构造函数时还不能确定对象的真实类型，因为子类会调用父类的构造函数，而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为
    
    23. 模板类是在什么时候实现的
    
        1. 模板实例化：模板的实例化分为显式实例化和隐式实例化，前者是研发人员明确告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板，不管是显式实例化还是隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的
        2. 模板具体化：当模板使用某种类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化，此时可以修改原模版的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理
    
    24. 类继承时，派生类对不同关键字修饰的基类方法的访问权限
    
        1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。
        2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。
        3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。
    
    25. 移动构造函数
    
        与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。
    
        移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。 而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。
    
    26. c++类内可以定义引用成员变量，但要遵循以下三个规则：
    
        1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
        2. 构造函数的形参也必须是引用类型。
        3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。
    
    27. 常函数
    
        类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立
    
    28. 虚继承
    
        解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题
    
    29. 虚函数和纯虚函数，以及实现原理
    
        1. 虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数
        2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” virtualvoid GetName() =0。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。
    
    30. 纯虚函数能实例化吗？为什么
    
        1. 纯虚函数不可以实例化，但是可以用其他派上类实例化
    
        2. 虚函数的原理采用vtable，类中含有纯虚函数时，其vtable不完全，有个空位
    
           即纯虚函数在类的vtable表中对应的表项被赋值为0，也就是指向一个不存在的函数，由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象，在他的派生类中，除非重写此函数，否则也不能生成对象，所以纯虚函数不能实例化
    
        3. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性
    
        4. 定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。
    
    31. 虚函数和纯虚函数的区别
    
        1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只有虚函数的类不能被称为抽象类
        2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义
        3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用
        4. 虚函数和纯虚函数通常存在于抽象基类中，被继承的子类重载，目的是提供一个统一的接口
        5. 虚函数的形式定义：virtual{}；纯虚函数的形式定义：virtual{}=0；在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定，然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样
    
    32. c++中什么是菱形继承问题，如何解决
    
        1. 假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。因为上述图表的形状类似于菱形，因此这个问题被形象地称为菱形继承问题
        2. 用virtual来标注可以解决
    
    33. 构造函数中能不能调用虚方法
    
        派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型，同样，进入基类析构函数时，对象也是基类类型，所以，虚函数始终仅仅调用基类的虚函数，如果是基类调用虚函数，不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果
    
    34. 拷贝构造函数的参数是什么传递方式，为什么
    
        1. 引用传递
        2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数，因此拷贝构造函数地参数必须是一个引用
        3. 传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的，事实上只有传引用不是传值外，其他所有的传递方式都是传值
    
    35. 抽象类
    
        1. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。
    
        2. 抽象类只能用作其他类的基类，不能建立抽象类对象。
    
           抽象类不能用作参数类型、函数返回类型或显式转换的类型。
    
           可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。
    
    36. 虚析构函数
    
        1. <img src="C:\Users\ZhouZixuan\AppData\Roaming\Typora\typora-user-images\image-20220303211129698.png" alt="image-20220303211129698" style="zoom:67%;" />
    
        2. 主要作用是防止内存泄露。
    
           定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。
    
           如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露
    
    37. 虚基类，能否被实例化
    
        1. 在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类
    
           ```c++
           class A
           class B1:public virtual A;
           class B2:public virtual A;
           class D:public B1,public B2;
           ```
    
           
    
        2. 虚继承的类可以被实例化
    
           ```c++
           class Animal {/* ... */ };
           class Tiger : virtual public Animal { /* ... */ };
           class Lion : virtual public Animal { /* ... */ }
           int main( )
           {
               Liger lg;
           
               /*既然我们已经在Tiger和Lion类的定义中声明了"virtual"关键字，于是下面的代码编译OK */
               int weight = lg.getWeight();
           }
           ```
    
    38. 拷贝赋值和移动赋值
    
        1. 拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象
    
        2. 移动赋值是通过移动构造函数来赋值，二者的主要区别在于
    
           1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；
    
           2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。
    
    39. 仿函数
    
        1. 又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符
        2. 仿函数既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息
    
    40. c++哪些函数不能被声明为虚函数
    
        1. 普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数
    
        2. 普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数
    
        3. 为什么C++不支持构造函数为虚函数？
    
           这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数
    
        4. 为什么C++不支持内联成员函数为虚函数？
    
           其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数
    
        5. 为什么C++不支持静态成员函数为虚函数？
    
           这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。
    
           静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别
    
        6. 为什么C++不支持友元函数为虚函数？
    
           因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。
        
    41. c++中类模板和模板类的区别
    
        1. 类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数
        2. 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。
    
    42. 虚函数表里存放的内容是什么时候写进去的
    
        1. 虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr，然后调用构造函数。即：虚表在构造函数之前写入
        2. 除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持
    
    43. STL基本组成部分
    
        标准模板库
    
        广义上讲，算法、容器、迭代器
    
        详细的说，容器、算法、迭代器、仿函数、适配器、空间制配器
    
        1. 容器是一种数据结构，如list，vector，deques，以模板类的方法提供，为了访问容器中的数据，可以用由容器类输出的迭代器
        2. 算法是用来操作容器中的数据的模板函数，例如STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此它们可以用于从简单数组到高度复杂容器的任何数据结构上
        3. 迭代器提供了访问容器中对象的方法，迭代器就如同一个指针，事实上，c++的指针也是一种迭代器，但是迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象
        4. 仿函数又称为函数对象，重载了操作符的struct
        5. 适配器是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或调用现有的函数来实现所需要的功能，主要包括3种适配器Container Adaptor，Iterator Adaptor，Function Adaptor
        6. 空间适配器为STL提供空间配置的系统，主要工作包括两部分：对象的创建和销毁，内存的获取和释放
    
    44. c++11新特性
    
        （1）统一的初始化方法
    
        （2）成员变量默认初始化
    
        （3）auto关键字  用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）
    
        （4）decltype  求表达式的类型
    
        （5）智能指针 shared_ptr
    
        （6）空指针 nullptr（原来NULL）
    
        （7）基于范围的for循环
    
        （8）右值引用和move语义  让程序员有意识减少进行深拷贝操作
    
        ​	C++ 语法上是支持定义常量右值引用的，但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。
    
        （9）无序容器（哈希表）  用法和功能同map一模一样，区别在于哈希表的效率更高
    
        （10）正则表达式  可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串
    
        （11）Lambda表达式
    
    45. 智能指针和指针的区别
    
        区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便地管理一个对象地生命期
    
    46. c++右值引用和转移语义
    
        1. 一般来说，不能取地址的表达式，就是右值引用，能取地址的，就是左值
    
           ```c++
           class A { }; 
           A & r = A(); //error,A()是无名变量，是右值 
           A && r = A(); //ok,r是右值引用
           
           //C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用
           int num = 10; 
           int &b = num; //正确 
           int &c = 10; //错误
           int num = 10; 
           const int &b = num; 
           const int &c = 10;
           
           //右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示
           int num = 10; 
           //int && a = num;  
           //右值引用不能初始化为左值 int && a = 10;
           
           //常量左值引用不同的是，右值引用还可以对右值进行修改
           int && a = 10; a = 100; cout << a << endl; /*程序运行结果：100*/
           //C++ 语法上是支持定义常量右值引用的
           const int&& a = 10;//编译器不会报错
           ```
    
           
    
        2. 转移语义，move本义为移动，但该函数并不能移动任何数据，他的功能很简单，就是将某个左值强制转化为右值，基于move()函数特殊的功能，其常用于实现移动语义
    
    47. auto
    
        用于定义变量，编译器可以自动判断变量的类型，auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的
    
        auto与const结合时，当类型不为引用时，auto的推导结果将不保留表达式的const属性；当类型为引用时，auto的推导结果将保留表达式的const属性
    
    48. 可变参数模板新特性
    
        可变参数模板(variadic template)使得编程者能够创建这样的模板函数和模板类，即可接受可变数量的参数。例如要编写一个函数，它可接受任意数量的参数，参数的类型只需是cout能显示的即可，并将参数显示为用逗号分隔的列表。
        
    49. Lambda 新特性（详细看）
    
        套用如下的语法格式：
    
        [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型{函数体; };